package classes.database;

import classes.fighterModule.SelectFighter;
import classes.fighterModule.fighters.Fighter;

import java.io.PrintWriter;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

/**
 * Class provides various database functionality.
 *
 *  Number:                Methods:
 *  -1-              registerPlayerInDB
 *  -2-              updateTable
 *  -3-              getField
 *  -4-              checkReadyPlayers
 *  -5-              createNewGameInDB
 *  -6-              getOpponentID
 *  -7-              registerFighterValuesInDB
 *
 */
public class DbLib {
    private PrintWriter out;
    private Connection con;

    public DbLib(PrintWriter out) {
        this.out = out;
    }



    /**
     * - 1 -
     *
     * This method will register a player in the database after a player
     * has written a player name, and chosen a fighter on the front page.
     * Player ID will be automatically generated by Class GenerateID.
     * @param playerName - The player name chosen be the player.
     * @param fighterName - The name of the fighter the player has chosen.
     * @throws SQLException
     * @return playerID
     */
    public String registerPlayerInDB(String playerName, String fighterName) throws SQLException {
        con = new DbTool().logIn(out);

        GenerateID idGen = new GenerateID();
        String playerID = idGen.getNewPlayerID();

        try {
            String stmt = "INSERT INTO battlegroundDB.player(playerID, playerName, fighterName) VALUES(?,?,?)";
            PreparedStatement pst = con.prepareStatement(stmt);
            pst.setString(1, playerID);
            pst.setString(2, playerName);
            pst.setString(3, fighterName);
            pst.executeUpdate();

            return playerID;
        }
        catch (SQLException e) {
            System.err.println("Exception in method insertIntoDB   " + e);
        }
        finally {
            closeConnections(out, con);
        }
        return null;
    }

    /**
     * - 2 -
     *
     * This method will update any table (change / insert a value on a table) in the battlegroundDB.
     * Example use: assign a gameID to a player.
     * @param table -           Which table to update.
     * @param columnToUpdate -  Which column to update.
     * @param valueToInsert -   Which value to be inserted.
     * @param columnIdName -    The name of the column that will identify the row to be updated.
     *                          This will most likely be an ID (I.e playerID or gameID).
     * @param valueOfColumnID - The value of the column name. If updating a value on a specific player,
     *                          This could be the value of the playerID.
     * @throws SQLException
     */
    public void updateTable(String table, String columnToUpdate, String valueToInsert, String columnIdName, String valueOfColumnID) throws SQLException {
        con = new DbTool().logIn(out);
        try {
            String stmt = "UPDATE battlegroundDB." + table +
                    " SET " + columnToUpdate + " = ?" +
                    " WHERE " + columnIdName + " = ?";

            PreparedStatement pst = con.prepareStatement(stmt);
            pst.setString(1, valueToInsert);
            pst.setString(2, valueOfColumnID);
            pst.executeUpdate();
        } catch (SQLException e) {
            System.err.println("Error in updateTable method -  " + e);
        } finally {
            closeConnections(out, con);
        }
    }

    /**
     * - 3 -
     *
     * getField will take parameters to create a SQL-statement that retrieves any single record of the
     * RoombookingDB-schema.
     * @param columnToSelect is the name of the record (column name) wanted.
     * @param tableToSearch is the name of the table the attribute is in.
     * @param columnIdName The name of the column that will identify the row to be updated.
     *                     This will most likely be an ID (I.e playerID or gameID).
     * @param columnIdValue The value of the column name. If updating a value on a specific player,
     *                      This could be the value of the playerID.
     * @return a String that contains the value of the record found.
     */
    public String getField(String columnToSelect, String tableToSearch, String columnIdName, String columnIdValue) throws SQLException {
        con = new DbTool().logIn(out);
        try {
            String stmt =   "SELECT " + columnToSelect +
                    " FROM battlegroundDB." + tableToSearch +
                    " WHERE " + columnIdName + " = ?";

            PreparedStatement pst = con.prepareStatement(stmt);
            pst.setString(1, columnIdValue);
            ResultSet searchResultSet = pst.executeQuery();

            if(searchResultSet.next()){
                String searchResult = searchResultSet.getString(1);
                return searchResult;
            }
        }
        catch (SQLException e){
            out.println("Exeption in getField: " + e);
        }finally {
            closeConnections(out, con);
        }
        return null;
    }

    /**
     *  - 4 -
     *
     * This method will check if there are more than 1 player with the same game ID.
     *
     * @param playerID The ID of the player that will check the gameID that is registered.
     * @return  true if there are more players with the same gameID.
     *          false if there is only 1 player with this gameID.
     * @throws SQLException
     */
    public boolean checkReadyPlayers(String playerID) throws SQLException {

        String gameIDToCheck = getField("gameID", "player", "playerID", playerID);

        con = new DbTool().logIn(out);

        try {
            String stmt = "SELECT gameID FROM battlegroundDB.player WHERE gameID = ?";
            PreparedStatement pst = con.prepareStatement(stmt);
            pst.setString(1, gameIDToCheck);
            ResultSet rs = pst.executeQuery();

            rs.last();
            if (rs.getRow() > 1) {
                return true;
            }
            else {
                return false;
            }

        }
        catch (SQLException e) {
            System.out.println("Error in DbLib.checkReadyPlayers() -  " + e);
        }
        finally {
            closeConnections(out, con);
        }
        return false;
    }

    /**
     *  - 5 -
     *
     * This method will put a newly generated gameID into the database, and
     * return the gameID as a String.
     * @return String - The newly generated gameID.
     * @throws SQLException
     */
    public String createNewGameInDB() throws SQLException {
        con = new DbTool().logIn(out);
        String gameID = new GenerateID().getNewGameID();

        try {
            String stmt = "INSERT INTO battlegroundDB.game(gameID) VALUES (?)";
            PreparedStatement pst = con.prepareStatement(stmt);
            pst.setString(1, gameID);
            pst.executeUpdate();

            return gameID;
        }
        catch (SQLException e) {
            System.out.println("Error on DbLib.createNewGameInDB " + e);
        }
        finally {
            closeConnections(out, con);
        }
        return null;
    }

    /**
     * - 6 -
     *
     *  This method is used to retrieve the opponent's playerID.
     * @param playerID - The ID of the player (NOT the opponent).
     * @param gameID - The ID of the game.
     * @return The attribute.
     * @throws SQLException
     */
    public String getOpponentID(String playerID, String gameID) throws SQLException {
        con = new DbTool().logIn(out);

        try {
            String stmt =   "SELECT playerID FROM battlegroundDB.player WHERE gameID = ?";

            PreparedStatement pst = con.prepareStatement(stmt);
            pst.setString(1, gameID);
            ResultSet searchResultSet = pst.executeQuery();

            searchResultSet.beforeFirst();
            while(searchResultSet.next()){
                String opponentID = searchResultSet.getString(1);
                if(!opponentID.equals(playerID)) {
                    return opponentID;
                }
            }
        }
        catch (SQLException e){
            out.println("Exeption in getOpponentID: " + e);
        }finally {
            if (con != null){
                con.close();
            }
        }
        return null;
    }

    /**
     * - 7 -
     *
     * When the fighter is selected, we want to register its base values into the database.
     */
    public void registerFighterValuesInDB(String playerID, String gameID, String fighterName) {
        Fighter fighter = new SelectFighter(out).getFighter(fighterName, playerID, gameID);
        fighter.setFighterToBaseValues();
        String maxHealth = Double.toString(fighter.getMaxHealth());
        String currentHealth = Double.toString(fighter.getCurrentHealth());
        String energy = Integer.toString(fighter.getEnergy());
        String damage = Double.toString(fighter.getDamage());
        String armour = Double.toString(fighter.getArmour());
        String critical = Double.toString(fighter.getCritical_chance());
        String dodge = Double.toString(fighter.getDodge_chance());

        try {
            updateTable("player", "maxHealth", maxHealth, "playerID", playerID);
            updateTable("player", "currentHealth", currentHealth, "playerID", playerID);
            updateTable("player", "energy", energy, "playerID", playerID);
            updateTable("player", "damage", damage, "playerID", playerID);
            updateTable("player", "armour", armour, "playerID", playerID);
            updateTable("player", "critical_chance", critical, "playerID", playerID);
            updateTable("player", "dodge_chance", dodge, "playerID", playerID);
        }
        catch (SQLException e) {
            System.out.println("Error in DbLib registerFighterValuesInDB() " + e);
        }
    }

    /**
     * Close connections after finishing the operation on the Database.
     */
    private void closeConnections(PrintWriter out, Connection con) throws SQLException {
        if (out != null) {
        }
        if (con != null){
            con.close();
        }
    }
}